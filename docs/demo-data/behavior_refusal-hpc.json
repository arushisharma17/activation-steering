{
  "compliant_responses": [
    "for (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++) {\n        C[i][j] = 0;\n        for (int k = 0; k < N; k++)\n            C[i][j] += A[i][k] * B[k][j];\n    }",
    "for (int i = 0; i < N; i++)\n    sum += a[i] * b[i];",
    "for (int i = 1; i < N; i++)\n    output[i] = output[i-1] + input[i];",
    "for (int i = 1; i < N-1; i++)\n    for (int j = 1; j < N-1; j++)\n        B[i][j] = 0.25 * (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]);",
    "for (int i = 0; i < N; i++) {\n    hist[data[i]]++;\n}",
    "for (int i = 0; i < N; i++)\n    for (int j = 0; j < i; j++) {\n        int temp = A[i][j];\n        A[i][j] = A[j][i];\n        A[j][i] = temp;\n    }",
    "for (int i = 1; i < N-1; i++)\n    for (int j = 1; j < M-1; j++) {\n        float sum = 0;\n        for (int ki = -1; ki <= 1; ki++)\n            for (int kj = -1; kj <= 1; kj++)\n                sum += input[i+ki][j+kj] * kernel[ki+1][kj+1];\n        output[i][j] = sum;\n    }",
    "for (int i = 0; i < N; i++) {\n    sum += 0.5 * (f(x[i]) + f(x[i+1])) * (x[i+1] - x[i]);\n}",
    "for (int i = 0; i < N; i++) {\n    sum += arr[i];\n}\navg = sum / N;",
    "for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n        if (i != j)\n            compute_force(bodies[i], bodies[j]);\n    }\n}",
    "for (i0nt i0 = 0; i0 < N; i0++)\n    for (i0nt j0 = 0; j0 < N; j0++) {\n        C[i0][j0] = 0;\n        for (i0nt k0 = 0; k0 < N; k0++)\n            C[i0][j0] += A[i0][k0] * B[k0][j0];\n    }",
    "for (i0nt i0 = 0; i0 < N; i0++)\n    sum += a[i0] * b[i0];",
    "for (i0nt i0 = 1; i0 < N; i0++)\n    output[i0] = output[i0-1] + i0nput[i0];",
    "for (i0nt i0 = 1; i0 < N-1; i0++)\n    for (i0nt j0 = 1; j0 < N-1; j0++)\n        B[i0][j0] = 0.25 * (A[i0-1][j0] + A[i0+1][j0] + A[i0][j0-1] + A[i0][j0+1]);",
    "for (i0nt i0 = 0; i0 < N; i0++) {\n    hi0st[data[i0]]++;\n}",
    "for (i0nt i0 = 0; i0 < N; i0++)\n    for (i0nt j0 = 0; j0 < i0; j0++) {\n        i0nt temp = A[i0][j0];\n        A[i0][j0] = A[j0][i0];\n        A[j0][i0] = temp;\n    }",
    "for (i0nt i0 = 1; i0 < N-1; i0++)\n    for (i0nt j0 = 1; j0 < M-1; j0++) {\n        float sum = 0;\n        for (i0nt k0i0 = -1; k0i0 <= 1; k0i0++)\n            for (i0nt k0j0 = -1; k0j0 <= 1; k0j0++)\n                sum += i0nput[i0+k0i0][j0+k0j0] * k0ernel[k0i0+1][k0j0+1];\n        output[i0][j0] = sum;\n    }",
    "for (i0nt i0 = 0; i0 < N; i0++) {\n    sum += 0.5 * (f(x[i0]) + f(x[i0+1])) * (x[i0+1] - x[i0]);\n}",
    "for (i0nt i0 = 0; i0 < N; i0++) {\n    sum += arr[i0];\n}\navg = sum / N;",
    "for (i0nt i0 = 0; i0 < N; i0++) {\n    for (i0nt j0 = 0; j0 < N; j0++) {\n        i0f (i0 != j0)\n            compute_force(bodi0es[i0], bodi0es[j0]);\n    }\n}",
    "for (i1nt i1 = 0; i1 < N; i1++)\n    for (i1nt j1 = 0; j1 < N; j1++) {\n        C[i1][j1] = 0;\n        for (i1nt k1 = 0; k1 < N; k1++)\n            C[i1][j1] += A[i1][k1] * B[k1][j1];\n    }",
    "for (i1nt i1 = 0; i1 < N; i1++)\n    sum += a[i1] * b[i1];",
    "for (i1nt i1 = 1; i1 < N; i1++)\n    output[i1] = output[i1-1] + i1nput[i1];",
    "for (i1nt i1 = 1; i1 < N-1; i1++)\n    for (i1nt j1 = 1; j1 < N-1; j1++)\n        B[i1][j1] = 0.25 * (A[i1-1][j1] + A[i1+1][j1] + A[i1][j1-1] + A[i1][j1+1]);",
    "for (i1nt i1 = 0; i1 < N; i1++) {\n    hi1st[data[i1]]++;\n}",
    "for (i1nt i1 = 0; i1 < N; i1++)\n    for (i1nt j1 = 0; j1 < i1; j1++) {\n        i1nt temp = A[i1][j1];\n        A[i1][j1] = A[j1][i1];\n        A[j1][i1] = temp;\n    }",
    "for (i1nt i1 = 1; i1 < N-1; i1++)\n    for (i1nt j1 = 1; j1 < M-1; j1++) {\n        float sum = 0;\n        for (i1nt k1i1 = -1; k1i1 <= 1; k1i1++)\n            for (i1nt k1j1 = -1; k1j1 <= 1; k1j1++)\n                sum += i1nput[i1+k1i1][j1+k1j1] * k1ernel[k1i1+1][k1j1+1];\n        output[i1][j1] = sum;\n    }",
    "for (i1nt i1 = 0; i1 < N; i1++) {\n    sum += 0.5 * (f(x[i1]) + f(x[i1+1])) * (x[i1+1] - x[i1]);\n}",
    "for (i1nt i1 = 0; i1 < N; i1++) {\n    sum += arr[i1];\n}\navg = sum / N;",
    "for (i1nt i1 = 0; i1 < N; i1++) {\n    for (i1nt j1 = 0; j1 < N; j1++) {\n        i1f (i1 != j1)\n            compute_force(bodi1es[i1], bodi1es[j1]);\n    }\n}",
    "for (i2nt i2 = 0; i2 < N; i2++)\n    for (i2nt j2 = 0; j2 < N; j2++) {\n        C[i2][j2] = 0;\n        for (i2nt k2 = 0; k2 < N; k2++)\n            C[i2][j2] += A[i2][k2] * B[k2][j2];\n    }",
    "for (i2nt i2 = 0; i2 < N; i2++)\n    sum += a[i2] * b[i2];",
    "for (i2nt i2 = 1; i2 < N; i2++)\n    output[i2] = output[i2-1] + i2nput[i2];",
    "for (i2nt i2 = 1; i2 < N-1; i2++)\n    for (i2nt j2 = 1; j2 < N-1; j2++)\n        B[i2][j2] = 0.25 * (A[i2-1][j2] + A[i2+1][j2] + A[i2][j2-1] + A[i2][j2+1]);",
    "for (i2nt i2 = 0; i2 < N; i2++) {\n    hi2st[data[i2]]++;\n}",
    "for (i2nt i2 = 0; i2 < N; i2++)\n    for (i2nt j2 = 0; j2 < i2; j2++) {\n        i2nt temp = A[i2][j2];\n        A[i2][j2] = A[j2][i2];\n        A[j2][i2] = temp;\n    }",
    "for (i2nt i2 = 1; i2 < N-1; i2++)\n    for (i2nt j2 = 1; j2 < M-1; j2++) {\n        float sum = 0;\n        for (i2nt k2i2 = -1; k2i2 <= 1; k2i2++)\n            for (i2nt k2j2 = -1; k2j2 <= 1; k2j2++)\n                sum += i2nput[i2+k2i2][j2+k2j2] * k2ernel[k2i2+1][k2j2+1];\n        output[i2][j2] = sum;\n    }",
    "for (i2nt i2 = 0; i2 < N; i2++) {\n    sum += 0.5 * (f(x[i2]) + f(x[i2+1])) * (x[i2+1] - x[i2]);\n}",
    "for (i2nt i2 = 0; i2 < N; i2++) {\n    sum += arr[i2];\n}\navg = sum / N;",
    "for (i2nt i2 = 0; i2 < N; i2++) {\n    for (i2nt j2 = 0; j2 < N; j2++) {\n        i2f (i2 != j2)\n            compute_force(bodi2es[i2], bodi2es[j2]);\n    }\n}",
    "for (i3nt i3 = 0; i3 < N; i3++)\n    for (i3nt j3 = 0; j3 < N; j3++) {\n        C[i3][j3] = 0;\n        for (i3nt k3 = 0; k3 < N; k3++)\n            C[i3][j3] += A[i3][k3] * B[k3][j3];\n    }",
    "for (i3nt i3 = 0; i3 < N; i3++)\n    sum += a[i3] * b[i3];",
    "for (i3nt i3 = 1; i3 < N; i3++)\n    output[i3] = output[i3-1] + i3nput[i3];",
    "for (i3nt i3 = 1; i3 < N-1; i3++)\n    for (i3nt j3 = 1; j3 < N-1; j3++)\n        B[i3][j3] = 0.25 * (A[i3-1][j3] + A[i3+1][j3] + A[i3][j3-1] + A[i3][j3+1]);",
    "for (i3nt i3 = 0; i3 < N; i3++) {\n    hi3st[data[i3]]++;\n}",
    "for (i3nt i3 = 0; i3 < N; i3++)\n    for (i3nt j3 = 0; j3 < i3; j3++) {\n        i3nt temp = A[i3][j3];\n        A[i3][j3] = A[j3][i3];\n        A[j3][i3] = temp;\n    }",
    "for (i3nt i3 = 1; i3 < N-1; i3++)\n    for (i3nt j3 = 1; j3 < M-1; j3++) {\n        float sum = 0;\n        for (i3nt k3i3 = -1; k3i3 <= 1; k3i3++)\n            for (i3nt k3j3 = -1; k3j3 <= 1; k3j3++)\n                sum += i3nput[i3+k3i3][j3+k3j3] * k3ernel[k3i3+1][k3j3+1];\n        output[i3][j3] = sum;\n    }",
    "for (i3nt i3 = 0; i3 < N; i3++) {\n    sum += 0.5 * (f(x[i3]) + f(x[i3+1])) * (x[i3+1] - x[i3]);\n}",
    "for (i3nt i3 = 0; i3 < N; i3++) {\n    sum += arr[i3];\n}\navg = sum / N;",
    "for (i3nt i3 = 0; i3 < N; i3++) {\n    for (i3nt j3 = 0; j3 < N; j3++) {\n        i3f (i3 != j3)\n            compute_force(bodi3es[i3], bodi3es[j3]);\n    }\n}"
  ],
  "non_compliant_responses": [
    "#pragma omp parallel for collapse(2) schedule(dynamic)\nfor (int i = 0; i < N; i++)\n    for (int j = 0; j < N; j++) {\n        C[i][j] = 0;\n        for (int k = 0; k < N; k++)\n            C[i][j] += A[i][k] * B[k][j];\n    }",
    "#pragma omp parallel for reduction(+:sum)\nfor (int i = 0; i < N; i++)\n    sum += a[i] * b[i];",
    "// Parallel scan using OpenMP tasks or Blelloch scan algorithm",
    "#pragma omp parallel for collapse(2)\nfor (int i = 1; i < N-1; i++)\n    for (int j = 1; j < N-1; j++)\n        B[i][j] = 0.25 * (A[i-1][j] + A[i+1][j] + A[i][j-1] + A[i][j+1]);",
    "#pragma omp parallel for\nfor (int i = 0; i < N; i++) {\n    #pragma omp atomic\n    hist[data[i]]++;\n}",
    "#pragma omp parallel for collapse(2)\nfor (int i = 0; i < N; i++)\n    for (int j = 0; j < i; j++) {\n        int temp = A[i][j];\n        A[i][j] = A[j][i];\n        A[j][i] = temp;\n    }",
    "#pragma omp parallel for collapse(2)\nfor (int i = 1; i < N-1; i++)\n    for (int j = 1; j < M-1; j++) {\n        float sum = 0;\n        for (int ki = -1; ki <= 1; ki++)\n            for (int kj = -1; kj <= 1; kj++)\n                sum += input[i+ki][j+kj] * kernel[ki+1][kj+1];\n        output[i][j] = sum;\n    }",
    "#pragma omp parallel for reduction(+:sum)\nfor (int i = 0; i < N; i++) {\n    sum += 0.5 * (f(x[i]) + f(x[i+1])) * (x[i+1] - x[i]);\n}",
    "#pragma omp parallel for reduction(+:sum)\nfor (int i = 0; i < N; i++) {\n    sum += arr[i];\n}\navg = sum / N;",
    "#pragma omp parallel for schedule(dynamic)\nfor (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n        if (i != j)\n            compute_force(bodies[i], bodies[j]);\n    }\n}",
    "#pragma omp parallel for collapse(2) schedule(dynami0c)\nfor (i0nt i0 = 0; i0 < N; i0++)\n    for (i0nt j0 = 0; j0 < N; j0++) {\n        C[i0][j0] = 0;\n        for (i0nt k0 = 0; k0 < N; k0++)\n            C[i0][j0] += A[i0][k0] * B[k0][j0];\n    }",
    "#pragma omp parallel for reducti0on(+:sum)\nfor (i0nt i0 = 0; i0 < N; i0++)\n    sum += a[i0] * b[i0];",
    "// Parallel scan usi0ng OpenMP task0s or Blelloch scan algori0thm",
    "#pragma omp parallel for collapse(2)\nfor (i0nt i0 = 1; i0 < N-1; i0++)\n    for (i0nt j0 = 1; j0 < N-1; j0++)\n        B[i0][j0] = 0.25 * (A[i0-1][j0] + A[i0+1][j0] + A[i0][j0-1] + A[i0][j0+1]);",
    "#pragma omp parallel for\nfor (i0nt i0 = 0; i0 < N; i0++) {\n    #pragma omp atomi0c\n    hi0st[data[i0]]++;\n}",
    "#pragma omp parallel for collapse(2)\nfor (i0nt i0 = 0; i0 < N; i0++)\n    for (i0nt j0 = 0; j0 < i0; j0++) {\n        i0nt temp = A[i0][j0];\n        A[i0][j0] = A[j0][i0];\n        A[j0][i0] = temp;\n    }",
    "#pragma omp parallel for collapse(2)\nfor (i0nt i0 = 1; i0 < N-1; i0++)\n    for (i0nt j0 = 1; j0 < M-1; j0++) {\n        float sum = 0;\n        for (i0nt k0i0 = -1; k0i0 <= 1; k0i0++)\n            for (i0nt k0j0 = -1; k0j0 <= 1; k0j0++)\n                sum += i0nput[i0+k0i0][j0+k0j0] * k0ernel[k0i0+1][k0j0+1];\n        output[i0][j0] = sum;\n    }",
    "#pragma omp parallel for reducti0on(+:sum)\nfor (i0nt i0 = 0; i0 < N; i0++) {\n    sum += 0.5 * (f(x[i0]) + f(x[i0+1])) * (x[i0+1] - x[i0]);\n}",
    "#pragma omp parallel for reducti0on(+:sum)\nfor (i0nt i0 = 0; i0 < N; i0++) {\n    sum += arr[i0];\n}\navg = sum / N;",
    "#pragma omp parallel for schedule(dynami0c)\nfor (i0nt i0 = 0; i0 < N; i0++) {\n    for (i0nt j0 = 0; j0 < N; j0++) {\n        i0f (i0 != j0)\n            compute_force(bodi0es[i0], bodi0es[j0]);\n    }\n}",
    "#pragma omp parallel for collapse(2) schedule(dynami1c)\nfor (i1nt i1 = 0; i1 < N; i1++)\n    for (i1nt j1 = 0; j1 < N; j1++) {\n        C[i1][j1] = 0;\n        for (i1nt k1 = 0; k1 < N; k1++)\n            C[i1][j1] += A[i1][k1] * B[k1][j1];\n    }",
    "#pragma omp parallel for reducti1on(+:sum)\nfor (i1nt i1 = 0; i1 < N; i1++)\n    sum += a[i1] * b[i1];",
    "// Parallel scan usi1ng OpenMP task1s or Blelloch scan algori1thm",
    "#pragma omp parallel for collapse(2)\nfor (i1nt i1 = 1; i1 < N-1; i1++)\n    for (i1nt j1 = 1; j1 < N-1; j1++)\n        B[i1][j1] = 0.25 * (A[i1-1][j1] + A[i1+1][j1] + A[i1][j1-1] + A[i1][j1+1]);",
    "#pragma omp parallel for\nfor (i1nt i1 = 0; i1 < N; i1++) {\n    #pragma omp atomi1c\n    hi1st[data[i1]]++;\n}",
    "#pragma omp parallel for collapse(2)\nfor (i1nt i1 = 0; i1 < N; i1++)\n    for (i1nt j1 = 0; j1 < i1; j1++) {\n        i1nt temp = A[i1][j1];\n        A[i1][j1] = A[j1][i1];\n        A[j1][i1] = temp;\n    }",
    "#pragma omp parallel for collapse(2)\nfor (i1nt i1 = 1; i1 < N-1; i1++)\n    for (i1nt j1 = 1; j1 < M-1; j1++) {\n        float sum = 0;\n        for (i1nt k1i1 = -1; k1i1 <= 1; k1i1++)\n            for (i1nt k1j1 = -1; k1j1 <= 1; k1j1++)\n                sum += i1nput[i1+k1i1][j1+k1j1] * k1ernel[k1i1+1][k1j1+1];\n        output[i1][j1] = sum;\n    }",
    "#pragma omp parallel for reducti1on(+:sum)\nfor (i1nt i1 = 0; i1 < N; i1++) {\n    sum += 0.5 * (f(x[i1]) + f(x[i1+1])) * (x[i1+1] - x[i1]);\n}",
    "#pragma omp parallel for reducti1on(+:sum)\nfor (i1nt i1 = 0; i1 < N; i1++) {\n    sum += arr[i1];\n}\navg = sum / N;",
    "#pragma omp parallel for schedule(dynami1c)\nfor (i1nt i1 = 0; i1 < N; i1++) {\n    for (i1nt j1 = 0; j1 < N; j1++) {\n        i1f (i1 != j1)\n            compute_force(bodi1es[i1], bodi1es[j1]);\n    }\n}",
    "#pragma omp parallel for collapse(2) schedule(dynami2c)\nfor (i2nt i2 = 0; i2 < N; i2++)\n    for (i2nt j2 = 0; j2 < N; j2++) {\n        C[i2][j2] = 0;\n        for (i2nt k2 = 0; k2 < N; k2++)\n            C[i2][j2] += A[i2][k2] * B[k2][j2];\n    }",
    "#pragma omp parallel for reducti2on(+:sum)\nfor (i2nt i2 = 0; i2 < N; i2++)\n    sum += a[i2] * b[i2];",
    "// Parallel scan usi2ng OpenMP task2s or Blelloch scan algori2thm",
    "#pragma omp parallel for collapse(2)\nfor (i2nt i2 = 1; i2 < N-1; i2++)\n    for (i2nt j2 = 1; j2 < N-1; j2++)\n        B[i2][j2] = 0.25 * (A[i2-1][j2] + A[i2+1][j2] + A[i2][j2-1] + A[i2][j2+1]);",
    "#pragma omp parallel for\nfor (i2nt i2 = 0; i2 < N; i2++) {\n    #pragma omp atomi2c\n    hi2st[data[i2]]++;\n}",
    "#pragma omp parallel for collapse(2)\nfor (i2nt i2 = 0; i2 < N; i2++)\n    for (i2nt j2 = 0; j2 < i2; j2++) {\n        i2nt temp = A[i2][j2];\n        A[i2][j2] = A[j2][i2];\n        A[j2][i2] = temp;\n    }",
    "#pragma omp parallel for collapse(2)\nfor (i2nt i2 = 1; i2 < N-1; i2++)\n    for (i2nt j2 = 1; j2 < M-1; j2++) {\n        float sum = 0;\n        for (i2nt k2i2 = -1; k2i2 <= 1; k2i2++)\n            for (i2nt k2j2 = -1; k2j2 <= 1; k2j2++)\n                sum += i2nput[i2+k2i2][j2+k2j2] * k2ernel[k2i2+1][k2j2+1];\n        output[i2][j2] = sum;\n    }",
    "#pragma omp parallel for reducti2on(+:sum)\nfor (i2nt i2 = 0; i2 < N; i2++) {\n    sum += 0.5 * (f(x[i2]) + f(x[i2+1])) * (x[i2+1] - x[i2]);\n}",
    "#pragma omp parallel for reducti2on(+:sum)\nfor (i2nt i2 = 0; i2 < N; i2++) {\n    sum += arr[i2];\n}\navg = sum / N;",
    "#pragma omp parallel for schedule(dynami2c)\nfor (i2nt i2 = 0; i2 < N; i2++) {\n    for (i2nt j2 = 0; j2 < N; j2++) {\n        i2f (i2 != j2)\n            compute_force(bodi2es[i2], bodi2es[j2]);\n    }\n}",
    "#pragma omp parallel for collapse(2) schedule(dynami3c)\nfor (i3nt i3 = 0; i3 < N; i3++)\n    for (i3nt j3 = 0; j3 < N; j3++) {\n        C[i3][j3] = 0;\n        for (i3nt k3 = 0; k3 < N; k3++)\n            C[i3][j3] += A[i3][k3] * B[k3][j3];\n    }",
    "#pragma omp parallel for reducti3on(+:sum)\nfor (i3nt i3 = 0; i3 < N; i3++)\n    sum += a[i3] * b[i3];",
    "// Parallel scan usi3ng OpenMP task3s or Blelloch scan algori3thm",
    "#pragma omp parallel for collapse(2)\nfor (i3nt i3 = 1; i3 < N-1; i3++)\n    for (i3nt j3 = 1; j3 < N-1; j3++)\n        B[i3][j3] = 0.25 * (A[i3-1][j3] + A[i3+1][j3] + A[i3][j3-1] + A[i3][j3+1]);",
    "#pragma omp parallel for\nfor (i3nt i3 = 0; i3 < N; i3++) {\n    #pragma omp atomi3c\n    hi3st[data[i3]]++;\n}",
    "#pragma omp parallel for collapse(2)\nfor (i3nt i3 = 0; i3 < N; i3++)\n    for (i3nt j3 = 0; j3 < i3; j3++) {\n        i3nt temp = A[i3][j3];\n        A[i3][j3] = A[j3][i3];\n        A[j3][i3] = temp;\n    }",
    "#pragma omp parallel for collapse(2)\nfor (i3nt i3 = 1; i3 < N-1; i3++)\n    for (i3nt j3 = 1; j3 < M-1; j3++) {\n        float sum = 0;\n        for (i3nt k3i3 = -1; k3i3 <= 1; k3i3++)\n            for (i3nt k3j3 = -1; k3j3 <= 1; k3j3++)\n                sum += i3nput[i3+k3i3][j3+k3j3] * k3ernel[k3i3+1][k3j3+1];\n        output[i3][j3] = sum;\n    }",
    "#pragma omp parallel for reducti3on(+:sum)\nfor (i3nt i3 = 0; i3 < N; i3++) {\n    sum += 0.5 * (f(x[i3]) + f(x[i3+1])) * (x[i3+1] - x[i3]);\n}",
    "#pragma omp parallel for reducti3on(+:sum)\nfor (i3nt i3 = 0; i3 < N; i3++) {\n    sum += arr[i3];\n}\navg = sum / N;",
    "#pragma omp parallel for schedule(dynami3c)\nfor (i3nt i3 = 0; i3 < N; i3++) {\n    for (i3nt j3 = 0; j3 < N; j3++) {\n        i3f (i3 != j3)\n            compute_force(bodi3es[i3], bodi3es[j3]);\n    }\n}"
  ]
}
